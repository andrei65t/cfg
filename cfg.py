import random

class CFG:
    def __init__(self):
        self.N=set()
        self.T=set()
        self.S=''
        self.P={}

def parser_cfg():
    cfg = CFG()
    while True:
        prod = input().strip()
        if prod=="":
            break
        else:
            NT, res = prod.split("->")
            NT=NT.strip()
            if cfg.S=='':
                cfg.S = NT.strip()
            cfg.N.add(NT)
            res = res.strip().split("|")
            for r in res:
                r=r.strip()
                if r!='':
                    if NT not in cfg.P:
                        cfg.P[NT]=[]
                    cfg.P[NT].append(r)
                    for char in r:
                        if char.islower():
                            cfg.T.add(char)
                        elif char!='^':
                            cfg.N.add(char)

    return cfg


def generate_strings(cfg):
    strings = set()

    def generate(current_string, depth):
        if len(strings) >= 10 or depth > 10:
            return
        if current_string == '^':
            strings.add('')
            return
        if all(c not in cfg.N for c in current_string):
            if len(current_string) <= 10:
                strings.add(current_string)
            return

        for i, char in enumerate(current_string):
            if char in cfg.N:
                productions = random.sample(cfg.P[char], len(cfg.P[char]))
                for production in productions:
                    if production == '^':
                        new_string = current_string[:i] + current_string[i+1:]
                    else:
                        new_string = current_string[:i] + production + current_string[i+1:]
                    generate(new_string, depth + 1)
                break  

    generate(cfg.S, 0)
    return list(strings)


def derivation_steps(cfg, target_input, strategy='left'):
    target = '' if target_input.strip()=='^' else target_input.strip()
    if not cfg.S: 
        return None
    def derive(curr, depth):
        max_d = max(len(target), 1) + len(cfg.N) + 5
        if depth > max_d or depth > 20: 
            return None
        idx = 0
        for ch in curr:
            if ch in cfg.T:
                if idx>=len(target) or ch!=target[idx]: 
                    return None
                idx+=1
            else: 
                break
        if all(ch not in cfg.N for ch in curr):
            return [curr] if curr==target else None
        positions = range(len(curr)) if strategy=='left' else range(len(curr)-1,-1,-1)
        for i in positions:
            if curr[i] in cfg.N:
                for prod in cfg.P.get(curr[i],[]):
                    nxt = curr[:i] + ('' if prod=='^' else prod) + curr[i+1:]
                    path = derive(nxt, depth+1)
                    if path: 
                        return [curr] + path
                break
        return None
    return derive(cfg.S,0)

def membership_test(cfg, w):
    return derivation_steps(cfg, w) is not None

cfg = parser_cfg()
print("Start symbol:", cfg.S)
print("Non-terminals:", cfg.N)
print("Terminals:", cfg.T)
print("Productions:")
for nt, rules in cfg.P.items():
    print(f"  {nt} -> {' | '.join(rules)}")
strings=generate_strings(cfg)
print("Generated strings:")
for s in strings:
    print(s if s else '^')

target = input("Enter a string to derive: ").strip()

left_derivation = derivation_steps(cfg, target, strategy='left')
right_derivation = derivation_steps(cfg, target, strategy='right')

print("\nLeftmost derivation:")
if left_derivation:
    print(" => ".join(left_derivation))
else:
    print("No leftmost derivation found.")

print("\nRightmost derivation:")
if right_derivation:
    print(" => ".join(right_derivation))
else:
    print("No rightmost derivation found.")


print("\nMembership test:")
target = input("Enter a string to test for membership: ").strip()
if membership_test(cfg, target):
    print(f"The string '{target}' is in the language generated by the CFG.")
else:
    print(f"The string '{target}' is NOT in the language generated by the CFG.")